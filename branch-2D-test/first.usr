c-----------------------------------------------------------------------
      subroutine usrdat2
      use mldat
      include 'SIZE'
      include 'TOTAL'
      
      integer :: eg1, eg2
!     real, dimension

c "1": UPPER CHANNEL: Power-law model of 0.3% Polyox WSR-301
c "2": LOWER CHANNEL: Pure water

c ### SIMILITUDE
c   length, time, and mass scales: sim. units per um, s, kg
      lsc = 1.0/48.0
      tsc = 1.0  
      msc = 9.069454E9    
c   Reynolds number
!     nre1 =     
!     nre2 = 

c ### FLUID MODEL
c   power law index
      n1 = 0.7859 
      n2 = 1.0000     
c   consistency index (K) or Newtonian viscosity (mu)
      udiff1 = 1.0966E4
      udiff2 = 3.8745E2
c   constant density
      param(1) = 1.0
c   constant heat capacity
!     param(7) = 1.0

c ### GEOMETRY
c   half-width or radius of branches
      rr1 = 0.5*58.0/48.0
      rr2 = 0.5*1.0 
c   branching angle: radians
      th = asin(0.5) ! 30 deg
c   inlet boundary:  perpendicular to branch: thi = th 
c                    parallel to y: thi = 0
      thi = th
c   branching point (along x)
      xbr = -30.0
c   y-coordinate on each branch INLET closest to y=0
      yy1 = 28.86750
      yy2 = -28.88833

c ### INLET PROFILE        
c   volumetric flow rates at branch inlets
!     q1 = 
!     q2 =
c   maximum velocities at branch inlets
      um1 = 18.772
      um2 = 22.620
c   allocate BC arrays
      allocate( uxbc  (lx1, ly1, lz1, lelt) )
      allocate( uybc  (lx1, ly1, lz1, lelt) )

c ### SOLVER FLAGS   
      param(30) = 1.    ! enable uservp()
      param(66) = 0.    ! output format (<0 = ASCII)
      param(67) = 0.    ! restart format 

c ### MESH MODIFICATION
c   branch elements at point of joining
      eg1 = 638 
      eg2 = 327
      
      call round_corner (eg1, -th)
      call round_corner (eg2,  th)
	  
      return
      end

c-----------------------------------------------------------------------
      subroutine round_corner (eg,th)
      include 'SIZE'
      include 'TOTAL'
c      
c     Modify straight corner to smooth parabola near merge point
c       eg:   corner element to be modified
c       th:   branching angle
c       dir1: y-direction of branch (-1: flow down, 1: flow up)
c       dir2: *********
c 
      integer e,eg,d1

      e = gllel(eg)

      d1 = int(sign(1.0,th))

      if (d1.eq.-1) then
         nl1 = ny1
      else
         nl1 = nx1
      endif

      real :: ll, sldx, sldy
      real, dimension(4,2) :: crnr
      real, dimension(nl1) :: slp, yint      
      real, dimension(nx1,ny1) :: pos
      
      slp(1) = tan(th)

      if (gllnid(eg).eq.nid) then
        
         crnr(1, :) = (/ xm1(  1,  1,1,e), ym1(  1,  1,1,e) /)
         crnr(2, :) = (/ xm1(nx1,  1,1,e), ym1(nx1,  1,1,e) /)
         crnr(3, :) = (/ xm1(  1,ny1,1,e), ym1(  1,ny1,1,e) /)
         crnr(4, :) = (/ xm1(nx1,ny1,1,e), ym1(nx1,ny1,1,e) /)

c        ADD CHECK TO SEE IF ELEMENT SIDE IS AT ANGLE THETA?
c        WHAT SHAPE IS PARABOLA IF WALL BOUNDARY IS PARALLEL
c        TO THE REST OF THE BRANCH??? SHOULDN'T WORK!
c        THE EQUATION FOR AA DOESN'T CONSIDER THIS, MAYBE WRONG?
c        OR MAYBE THERE IS ONLY ONE PARABOLA FOR EACH YS, YZ, THETA??

!        to generalize this completely: start from the unadjusted mesh
!        and move x0 manually. 
!        most general form would need to :
!         -automatically identify the four elements that intersect
!          at the branching point (0,0)
!         -allow the user to specify the "roundness" of the corner
     
c        branching point
         yz = crnr(1, 2)
c        farthest corner on wall boundary
         ys = abs( crnr(minloc( crnr(:,1) ), 2) )
         aa = -1./( 2. * (ys - yz) * abs(slp) )

!        slopes of GLL lines emerging from wall boundary
         
         do i=2,nl1-1
            if (d1.eq.1) then
               sldx = xm1(i,1,1,e) - xm1(i,ny1,1,e)
               sldy = ym1(i,1,1,e) - ym1(i,ny1,1,e)
               slp(i) = sldy/sldx
               yint(i) = ym1(i,1,1,e) - slp*xm1(i,1,1,e)
            else
               sldx = xm1(1,i,1,e) - xm1(nx1,i,1,e)
               sldy = ym1(1,i,1,e) - ym1(nx1,i,1,e)
               slp(i) = sldy/sldx
               yint(i) = ym1(1,i,1,e) - slp*xm1(1,i,1,e)
            endif
         enddo

!        find position (from 0-1) of each point on each line,
!        from one side of the element to the other

         do i=2,nl1-1
            
            if (d1.eq.1) then
               ll = ( yint(i) - ym1(i,1,1,e) )/sin(th)
               do j=2,ny1-1
                  pos(i,j) = ((yint(i) - ym1(i,j,1,e))/sin(th))/ll
               enddo
               
               xm1(i,1,1,e) = 
               ym1(i,1,1,e) = 
               
               do j=2,ny-1
                  xm1(i,j,1,e) = 
                  ym1(i,j,1,e) =
               enddo
            else
               ll = ( yint(i) - ym1(1,i,1,e) )/sin(th)
               do j=2,nx1-1
                  pos(j,i) = ((yint(i) - ym1(j,i,1,e))/sin(th))/ll
               enddo
            endif
         enddo

!        move boundary points to intersection of parabola with lines

!        move internal points to new points (same 0-1 relative position)
!        on their lines, based on the new distance between the boundary
!        points (parabola) and the opposite internal boundary (straight, theta)

!        perhaps need to call fix_geom

         do i=2,nx1-1
            do j=1,ny1-1
               do k=1,nz1

                  
                  ym1(i,j,k,eg1)
                  ym1(i,j,k,eg2)

               enddo
            enddo
         enddo

      endif      

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)
      use mldat
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      
      integer ieg
      
      if (ifield.eq.1) then
      if(istep.le.1) then

          udiff = udiff1

      else
!       interpolate between fluid models based on diffusion
          udiffn1 = udiff1*shvis(ix,iy,iz,gllel(ieg))
          udiffn2 = udiff2
          plc0 = (udiffn1-udiffn2)*(temp-udiff2)/(udiff1-udiff2)          
          if (plc0 .le. -udiffn2) plc0 = -udiffn2 + 10e-6
!           viscosity must be positive...
            plc=udiffn2+plc0

          udiff = plc	

      endif
      
      utrans = param(1)
      else
        udiff = 1.0E-04
        utrans= param(7)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      use mldat
      include 'SIZE'
      include 'TOTAL'
      
      real gc
      real, allocatable, dimension(:,:,:,:) :: gamma	  
      real :: um, nn, rr, yy, ydir, hh, upro

!     strain rate invariants (nek built-in)
      common /screv/ ei2(lx1,ly1,lz1,lelt)
     $             , ei3(lx1,ly1,lz1,lelt)

!     might not be necessary with further debugging
      if (allocated(shvis)) deallocate(shvis)
      allocate( gamma  (lx1, ly1, lz1, lelt) )   
      allocate( shvis  (lx1, ly1, lz1, lelt) )
         
      ntot1  = nx1*ny1*nz1*nelv
      
      if (istep.eq.0) then
        do i=1,ntot1
          x = xm1(i,1,1,1)
          y = ym1(i,1,1,1)

          if (Y.GT.0.0) then
            um = um1
            nn = n1
            rr = rr1
            yy = yy1
            ydir = -1.0
            !write(*,*) "n1 = ",n1, "; nn = ",nn!,"; hh = ",hh
          else
            um = um2
            nn = n2
            rr = rr2
            yy = yy2
            ydir = 1.0
          endif

!         distance from the center of inlet boundary      
          hh = (y-yy)/cos(thi)
          hh = abs(abs(hh)-rr)/rr
          
          if (hh.gt.0 .and. hh.le.1) then
            
            upro = (1.0-hh**(1.0+1.0/nn))  
          else
            upro = 0
          endif    
          
          uxbc(i,1,1,1) = upro*um*cos(th)
          uybc(i,1,1,1) = upro*um*ydir*sin(th)

        enddo
      endif

!     calculate strain rate components (nek built-in)
      call stnrinv

      do ieg= 1, nelgt
      if (gllnid(ieg).eq.nid) then
!      "if this element is the responsibility of this core"
!      necessary (?) for parallel computation
        iel = gllel(ieg)
          
          do K = 1, nz1
           do J = 1, ny1
            do I = 1, nx1
            
!             need shear rate for power-law model
              gamma(i,j,k,iel)=(0.5*abs(ei2(i,j,k,iel)))**0.5
			  
!             keep track of lowest non-zero shear rate
              gc = gamma(i,j,k,iel)
              if (gc.lt.gm .and. gc .gt. 0.0) then
                gm = gc
              end if
              
            end do
           end do
          end do
          
          do K = 1, nz1
           do J = 1, ny1
            do I = 1, nx1
              
!             if shear rate is 0 and n<1:
!                n .lt. 1: div by 0 in power-law model
!                n .ge. 1: 0 assigned to udiff (nek rejects)
              if (gamma(i,j,k,iel) .lt. gm) then
                gamma(i,j,k,iel) = gm
              end if
              
!             used in uservp to assign udiff
!             currently only calculated for upper ("1") branch
              shvis(i,j,k,iel)=(gamma(i,j,k,iel))**(n1-1.0)
              
              if (shvis(i,j,k,iel) .le. 0.0) then
                write(89,*) shvis(i,j,k,iel)
              end if
            end do
           end do
          end do
           
      end if
      end do
      
!     must reset the shear rate tracker
      gm = 1e38
      
      if (mod(istep,iostep).eq.0) then 
        ! output shear rate and variable component of viscosity
        call outpost(vx,gamma,vz,pr,t,'shr')
      endif 
 
      deallocate(gamma)

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,eg)
      use mldat
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      
      integer e, eg
      
      e = gllel(eg)
      
      if (ifield.eq.1) then
      
        ux = uxbc(ix,iy,iz,e)
        uy = uybc(ix,iy,iz,e)
        uz = 0.0

      elseif (ifield.eq.2) then

        if (Y.GT.0.0) then
          temp=udiff1
        else
          temp=udiff2
        endif

      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      use mldat
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ux = 0.0
      uy = 0.0
      uz = 0.0

      if (Y.GT.0.0) then
        temp=udiff1
      else
        temp=udiff2
      endif
      
      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)

      ffx = 0.0
      ffy = 0.0
      ffz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)

      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
c
      
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      use mldat
      include 'SIZE'
      include 'TOTAL'
c
      return
      end
c-----------------------------------------------------------------------
